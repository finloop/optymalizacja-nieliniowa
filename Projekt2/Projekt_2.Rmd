---
title: "Projekt Optymalizacja nieliniowa"
author: |
  | Krawiec Piotr
  | Inżynieria i analiza danych, 3 Rok
date: "01/12/2021"
output:
  beamer_presentation:
    theme: Antibes
    keep_tex: yes
  slidy_presentation: 
    theme: united
    highlight: tango
description: Inżynieria i analiza danych, 3 Rok
header-includes: \usepackage{animate}
subtitle: Cz 2 Optymalizacja wielowymiarowa
lang: pl
always_allow_html: true
---

```{r setup, include=FALSE, warning=FALSE}
library(knitr)
hook_output <- knit_hooks$get("output")
knit_hooks$set(output = function(x, options) {
  lines <- options$output.lines
  if (is.null(lines)) {
    return(hook_output(x, options))  # pass to default hook
  }
  x <- unlist(strsplit(x, "\n"))
  more <- "..."
  if (length(lines)==1) {        # first n lines
    if (length(x) > lines) {
      # truncate the output, but add ....
      x <- c(head(x, lines), more)
    }
  } else {
    x <- c(more, x[lines], more)
  }                                                         
  # paste these lines together                              
  x <- paste(c(x, ""), collapse = "\n")                     
  hook_output(x, options)                                   
})                                                          
knitr::opts_chunk$set(echo = TRUE)                          
knitr::opts_chunk$set(cache = TRUE) 
knitr::opts_chunk$set(echo = TRUE, fig.align="center")
Sys.setlocale("LC_ALL", "Polish")
```
# Wstęp

Celem tej pracy jest omówienie metody gradientów sprzężonych Polaka-Ribiere'a,
jej implementacja w R oraz rozwiązanie z jej pomoca zadania optymalizacyjnego.

# Problem

Istnieje wiele algorytmów optymalizacji co zrodziło potrzebę porównania ich, wyłonienia, który jest najlepszy. Do tego celu powstały funkcje testujące algorytmy optymalizacji ^[https://en.wikipedia.org/wiki/Test_functions_for_optimization] . Ich pierwszy zbiór został stworzony jako pakiet w programie Matlab przez Rody Oldenhuis i zawierał 50 funkcji testowych.

![Funkcja Rastrigina](img/Rastrigin_function.png){ width=50% }

# Inne przykłady: Funkcja Rosenbrock'a oraz Goldstein'a-Price'a


![Funkcja Rosenbrock'a](img/Rosenbrock's_function.jpg){ width=45% } ![Funkcja Goldstein'a-Price'a ](img/Goldstein_Price_function.pdf.jpg){ width=45% }

# Zadanie

Zadaniem będzie znalezienie minimum funkcji Goldstein'a-Price'a o następującym równaniu:

$$
f(x,y)=\left[1+\left(x+y+1\right)^{2}\left(19-14x+3x^{2}-14y+6xy+3y^{2}\right)\right]
$$

```{r}

f <- function(x, y) {
  (1 + (x + y + 1)^2 * 
  (19 - 14 + 3*x^2 - 14*y + 6*x*y + 3*y^2)) *
  (30 + (2*x - 3*y)^2*(18 - 32*x + 12*x^2 
      + 48*y-36*x*y + 27*y^2))
}
```


# Wykres funkcji

```{r, echo=FALSE}
x <- seq(-1.5, 1.5, length.out=200)
y <- seq(-1.5, 1.5, length.out=200)
z <- outer(x, y, f)
contour(x, y, z, levels=seq(0, 100, 2)^2)
```

# Wykres funkcji - zbliżenie na miejsce zerowe

```{r, echo=FALSE}
x <- seq(-1, 1, length.out=200)
y <- seq(-1.4, 0, length.out=200)
z <- outer(x, y, f)
contour(x, y, z, levels=seq(0, 100, 2)^2)
```

```{r eval=FALSE, include=FALSE}
x <- seq(-0.5, 0.5, length.out=50)
y <- seq(-1.4, 0, length.out=50)
z <- outer(x, y, f)

for (i in seq(1, 90, 10)){
 jpeg(filename = paste("img/", i ,".jpeg" ,sep=""),  width = 1200, height = 900)
 cat(paste("img/", i ,".jpeg", "\n" ,sep=""))
 persp(x,y,z, theta=i,phi=30,expand=0.4,col = "lightblue",xlab = "X",
 ylab = "Y", zlab = "Z",ticktype = "detailed")
 dev.off()
}
```
# Wykres - 3D

![](img/1.jpeg)
# Wykres - 3D

![](img/11.jpeg)

# Wykres - 3D

![](img/21.jpeg)

# Wykres - 3D

![](img/31.jpeg)

# Wykres - 3D

![](img/41.jpeg)

# Wykres - 3D

![](img/51.jpeg)

# Wykres - 3D

![](img/61.jpeg)

# Wykres - 3D

![](img/71.jpeg)

# Wykres - 3D

![](img/81.jpeg)


```{r eval=FALSE, fig.height=8, fig.width=12, message=FALSE, warning=FALSE, include=FALSE, paged.print=FALSE}
library(plotly)
x <- seq(-1.2, 0.5, length.out=50)
y <- seq(-1, 0, length.out=50)
z <- outer(x, y, f)

fig <- plot_ly()
fig <- fig %>% add_surface(z = z, x = x, y  = y, colorscale = "Rainbow")
fig
```


```{r}
golden <- function(f, lower, upper, tol) {
ratio <- 2 / (3 + sqrt(5))
x1 <- (1 - ratio) * lower + ratio * upper
f.x1 <- f(x1)
while (abs(upper - lower) > 2 * tol) {
x2 <- (1 - ratio) * x1 + ratio * upper
f.x2 <- f(x2)
if (f.x1 < f.x2) {
upper <- lower
lower <- x2
} else {
lower <- x1
x1 <- x2
f.x1 <- f.x2
}
}
return((upper + lower) / 2)
}
```

```{r}
library(numDeriv)
polak.ribiere <- function(f, x, tol) {
  beta <- 1;
  # Ograniczenie gradientu
  d <- -grad(f,x)/max(abs(grad(f,x)))/5 
  repeat {
    g <- function(a) {f(x + a * d)}
    grad.x <- grad(f, x)
    step <- golden(g,-2,0,tol)
    new.x <- x + step * d
    grad.new.x <- grad(f, new.x)
    if (dist(rbind(new.x,x)) < tol) {
      return(new.x)
    }
    beta <- t(grad.new.x) %*%
              (grad.new.x - grad.x) /
              (t(grad.x) %*% grad.x)
    d <- -grad(f,new.x) + as.vector(beta) * d
    x <- new.x
  }
}

fn <- function(x) f(x[1], x[2]);
```

```{r}
m <- fletcher.reeves(fn, c(-0.5, -1.0), 1e-3)
m
fn(m)
```


















